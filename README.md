# RKN

Работает на debian like OS

## Установка:

1. Клонируем git
2. ```cd RKN/ && ./install.sh``` 

## Настройка:

### Выгрузка:
Первым делом надо составить и подписать запрос электронной подписью оператора связи для получения выгрузки.

Формат запроса в xml:
```
<?xml version="1.0" encoding="windows-1251"?>
<request>
<requestTime>[Время]</requestTime>
<operatorName>[Имя организации]</operatorName>
<inn>[ИНН]</inn>
<ogrn>[Номер организации]</ogrn>
<email>[E-mail]</email>
</request>
```
**Обязательно** не забываем обновлять электронную подпись и переподписывать файл, иначе могут возникнуть проблемы с получением реестра.

### Файл white_dom.list:

В данном файле находится список доменов, которые необходимо блокировать по-странично, т.е. крайне не желательно блокировать весь домен из списка.
По умолчанию список пуст, значит ограничиваться будет все по-доменно, кроме тех ресурсов, где домена не указанно.

Пример списка:
```
vk.com
www.vk.com
youtube.com
www.youtube.com
youtu.be
```
### Конфиг логов:

Хранится по-умолчанию в файде **logger.conf.**
Логирование осуществляется python библиотекой **logging**

Что можно поменять?
1. В директиве **[logger_root]** *handlers=* изменить на *handlers=consoleHandler*, для вывода логов помимо файла в консоль.
2. В любой директиве описания логеров изменить параметр *level=* на *CRITICAL, INFO, DEBUG*, т.о. мы изменим уровень логирования соответствующего логера.
3. В директиве **[handler_fileHandler]** *args=("/var/log/rkn-worker.log",)* изменить на любой файл, в который вы хотите заносить логи.
4. В директиве **[formatter_myFormatter]** изменить *format=*, т.о. вы измените формат вывода записи.
По умолчанию *%(asctime)s - %(name)s - %(levelname)s - %(message)s*, что выглядит так: 
```
2018-09-13 10:06:51,518 - class.daemon - INFO - Update data from new dump...
```
5. В директиве **[formatter_myFormatter]** изменить *datefmt=*, т.о. вы измените формат вывода даты.

Подробнее о формате файла в [туториале](https://docs.python.org/3/library/logging.html)

### Основной конфиг:

Все настройки по умолчанию содержатся в файле **conn.conf**.

Имеются 3 основных директивы и 4 дополнительных, для описания сервисов.

Обязательные:
### [CONN]

Содержит настройки подключения к базе данных:
* **HOST** - IP-адрес сервера с базой данных;
* **USER** - пользователь для подключения;
* **PASS** - пароль для подключения;
* **DB** - База данных.

### [DUMP]

Содержит настройки для выгрузки реестра:
* **API_URL** - URL удаленного сервера РКН;
* **XML_FILE_NAME** - xml-файл запроса на получение выгрузки;
* **SIG_FILE_NAME** - сигнатура файла запроса;
* **RES** - имя получаемого архива;
* **VERS** - версия (узнаем в РКН);
* **COUNT_TRY** - количество попыток загрузки реестра.

Не обязательный:
### [DAEMON]

Содержит настройки для работы сервиса:
* **COUNT_TRY** - количество попыток загрузки реестра;
* **TIMEOUT** - таймаут опроса обновления выгрузки РКН (в секундах);
* **UPDATE_TIMEOUT** - максимальное время применения изменений (в часах. можно поставить 0, тогда обновлятся будет постоянно, что довольно опасно);
* **TIMEZONE** - временная зона (0 - МСК).

Сервисы:
### [BGP]

Содержит настройки для взаимодействия с BGP (анонсим сети, которые необходимо завернуть на фильтр):
* **service** - сервис (я использую /etc/init.d/bgpd из пакета quagga);
* **head** - файл с постоянными настройками bgp;
* **work** - работа для перезапуска сервиса (в quagga есть только *restart*);
* **edit** - команда при добавлении/удалении записей (у меня такая *vtysh -c "conf t" -c "router bgp 65001" -c*);
* **conf_file** - файл конфига текущего ВGP;
* **file** - сгенерированный файл с конфигом BGP;
* **weight** - вес разности между сгенерированным файлом и текущим (у меня 0.5).

Если рейтинг разности меньше веса, то перезапускаем сервис с новыми настройками, если больше используем команду и фиксим настройки "мягко".

### [IPTABLES]

Содержит настройки для взаимодействия с IPTABLES (ограничиваем по IP или подсетям):
* **file** - сгенерированный файл с правилами для iptables;
* **head** - заголовочный файл с постоянными правилами iptables;
* **tail** - конечный файл с постоянными правилами iptables;
* **host** - IP-адрес:порт редиректа для правила;
* **weight** - вес разности между сгенерированным файлом и текущим (у меня 0.8).

Принцип такой же как в BGP: Если рейтинг разности меньше веса, то полнсотью переписываем правила, если больше используем правила и фиксим настройки "мягко".

### [PROXY]

Содержит настройки для взаимодействия с Proxy (ограничиваем по доменам или ссылкам):
* **service** - сервис (я использую например squid);
* **work** - работа по перезапуску сервиса;
* **init** - путь к сервису для перезапуска;
* **timeout** - таймаут рестарта Proxy в часах;
* **dom_file** - сгенерированный файл с regexp доменами;
* **url_file** - сгенерированный файл с regexp ссылками;
* **rev_file** - сгенерированный файл с reverse доменами;
* **gen_wfile** - сгенерированный файл с reverse доменами из белого списка;
* **re_dom_conf** - файл конфигурации с regexp доменами для сервиса;
* **dom_conf** - файл конфигурации с reverse доменами для сервиса;
* **url_conf** - файл конфигруации с ссылками для сервиса;
* **white_conf** - файл со списком reverse доменов, которые следует разбирать по ссылкам.

У squid есть есть известные проблемы с много-задачностью, поэтому я, к примеру, использую подпрограмму для разбора ссылок.

### [DNS]

* **host** - список IP-адресов DNS'ов;
* **file** - сгенерированный файл с доменами;
* **cmd** - команда для передачи списка доменов для DNS (я использую *scp*, можно реализовать больше, но было бы желание...);
* **path** - путь, куда положить файл на сервере;
* **user** - пользователь, под которым осуществить передачу.

Я перемещаю файлы с доменами на 2 сервера с bind, на них находится скрипт, который состовляет зоны и ограничивает подоменно.
Зачем вообще нужна работа с сервисом DNS?
Да, в целом очень плохо подменять NS-ответы, но приходится выбирать из 2х зол.  
Во-первых получаем экономию по трафику на фильтре, отсеив большиство пользователей на этапе резолвинга. 
Во-вторых получаем возможность полностью избежать DNS-атаки на РКН. [Подробнее](https://usher2.club/articles/dns-attack-2017/)

## Ключи запуска:
```
./worker [--start] [--clear] [--conf file] [--log file] [--err file/new] [--bgp] [--iptables] [--dns] [--proxy]
```
* *--start* - запуск сервиса;
*	*--clear* - полная зачистка БД;
* *--conf file* - указать файл с конфигой, по умолчанию **conn.conf**;
* *--log file* - файл с конфигурацией логов, если не указан, то выводит в терминал;
*	*--err file/new* - проверить файл с выгрузкой на ошибки, если указано *new*, то скачает свежую выгрузку, не работает с ключом *--start*;
* *--bgp* - включить взаимодействие с сервисом BGP;
*	*--iptables* - включить взаимодействие с правилами iptables; 
* *--dns* - включить взаимодействие с DNS;
* *--proxy* - включить взаимодействие с proxy.

## Сервис:
```
Usage: /etc/init.d/rkn-workerd { start | stop | restart |  status | clear | check-dump | full-restart }
```
* *start* - запустить (--start --log $log --iptables --bgp --dns --proxy по умолчанию);
* *stop* - остановить;
* *restart* - перезапустить (stop + start);
* *status* - статус;
* *clear* - очищает базу данных;
* *check-dump* - проверка "свежей" выгрузки на ошибки;
* *full-restart* - "начнем все с нуля" (stop + clear + start).

1. Необходимо исправить dir внутри сервиса, если отлично от /home/RKN.
2. Необходимо поправить *start*, если есть необходимость отсечь ненужные сервисы или исправить пути файлов конфигураций. 
